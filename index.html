<script src='./tree.js'>
</script>

<script>
var flowTree;
constructTree(['Q1','A1.1','Q3','A2.2','End'],0);
constructTree(['Q1','A1.2','Q2','A2.1','End'],1);
constructTree(['Q1','A1.3','Q3','A2.3','End'],2);


function constructTree(arr, indx) {
    var i = 1;
    if (indx == 0) {
        flowTree = new Arboreal(null, {
            label: arr[0]
        });
    }
     while (i < arr.length) {
        if (!flowTree.children[indx] && i ==1) {
            flowTree.appendChild({
                label: arr[i]
            })
       
        } else {
           flowTree = findLastAndAppend(flowTree, i, indx, arr[i])
        }
    
        i++;   
    }
    
}

function iterator(node) {
    var depth = "",i;
    for (i = 1; i <= node.depth; i++) depth += ">";
    console.log([depth, node.data.label].join(" "));
}


setTimeout(() => {
    flowTree.traverseDown(iterator)
    console.log(getNextQueOrder('A2.2'))
}, 3000
)


// assuming keys are unique . need to find the child of the key - the next que to be asked
function getNextQueOrder(key) {
   return flowTree.find(function (node) {
        return key ===node.data.label
      })
}


function createChildNodes( flowT, count, indx ){
    //console.log('logger --', flowTree.children,'---count',count)

    for(var x = flowTree.children[indx].depth ; x<=count;x++)

    flowTree.children

}


function findLastAndAppend(flowTree , dep, indx, label){

    var tree  = Object.assign({},flowTree);
   
    for(i=0; i <=dep-1 && tree!=null;i++) {
    
        if(tree.children.length == 0 ) {
        
            tree.appendChild({
                label: label
            })
        
        }
        else{ 
            tree = tree.children[ i== 0 ?indx : 0];   
        } 
    }

    return tree;
    
}

</script>